import threading
import socket
import sys
from collections import Counter
import time


#class for auction 
class Auction:
            def __init__(self):
                self.start_price = 1
                self.current_highest_bid = self.start_price
                self.highest_bidder = None
                self.auction_in_progress = True
                self.last_bid_time = None

            def start_auction(self):
                self.auction_in_progress = True
                self.last_bid_time = time.time()

            def bid(self, bid_amount, bidder):
                if bid_amount > self.current_highest_bid:
                    self.current_highest_bid = bid_amount
                    self.highest_bidder = bidder
                    self.last_bid_time = time.time()
                    return True
                return False

            def check_auction_end(self):
                if self.auction_in_progress and (time.time() - self.last_bid_time) > 10:
                    return True
                return False

auction = Auction()


# Have to use a class to perform threading
class ClientHandler(threading.Thread):
    def __init__(self, client_socket, address, active_connections, voting_list):
        #Handler initalising itself
        super().__init__()
        self.client_socket = client_socket
        self.address = address
        self.active_connections = active_connections
        self.max_attempts = 3
        self.voting_list=voting_list


    def run(self):
        try:
                self.initial_message()
                
        finally:
            #Closes the connections at the end if not already closed
            self.close_connection()
        
    def initial_message(self):
        #Send our opening message and the riddle
        ##self.broadcast("TESTING1")        
        riddle = "\nHello, I am a server that can offer information about other clients, once a voting consensus has been reached.\nTo cast your vote you must be able to answer a riddle correctly. What services does your client offer?"
        print(f"Sending: {riddle}")
        self.client_socket.send(riddle.encode())
        #Decode and strip the white space of the reply, then check for expected answers
        answer = self.client_socket.recv(1024).decode().strip()
        print(f"Received answer: {answer}")
        #self.broadcast("Testing2")
        #Server chooses if they want this client to join its network
        sentence = input("Does the server want this client to enter the network? ")
        if sentence.lower() == "yes":
            self.riddle()
        else: self.close_connection

    def riddle(self):
        riddle = "David’s parents have three sons: Snap, Crackle, and what’s the name of the third son?"
        print(f"Sending: {riddle}")
        self.client_socket.send(riddle.encode())
        #Decode and strip the white space of the reply, then check for expected answers
        answer = self.client_socket.recv(1024).decode().strip()
        print(f"Received answer: {answer}")
        if answer.lower() == "david":
            self.correct_answer()
        else: 
            self.incorrect_answer()
    def correct_answer(self):
        #if client answers correctly, it can cast its vote
        info_message = f"Correct answer! Would you to cast your vote?"
        print(f"Sending: {info_message}")
        self.client_socket.send(info_message.encode())
        sentence = self.client_socket.recv(1024).decode().strip()
        print(f"Received: {sentence}")
        if sentence.lower() == 'yes':
            self.yes_message()
        else: 
            self.no_message()
                
    def yes_message(self):
        #self.broadcast("testing3")

        vote_message = "Enter your a letter of the alphabet for your vote:"
        print(f"Sending: {vote_message}")
        self.client_socket.send(vote_message.encode())
        vote = self.client_socket.recv(1024).decode().strip()
        print(f"Received vote: {vote}")
        with global_lock:
            #Add the vote to the list that can be accessed by all threads
             self.voting_list.append(vote)
        self.find_consensus()

    def no_message(self):
        #If the client does not vote, it cannot be apart of the consensus and therefore, connection needs to be closed
        info_message = f"Clients cannot receive information without casting a vote\nEnter yes to go back to voting or anything else to close the connection"
        print(f"Sending: {info_message}")
        self.client_socket.send(info_message.encode())
        sentence = self.client_socket.recv(1024).decode().strip()
        print(f"Received: {sentence}")
        if sentence.lower() == 'yes':
            self.yes_message()
        else: self.close_connection
        
    
    def find_consensus(self):
        #vote_list_str = ', '.join(self.voting_list)
        #info_message = f"Ok All votes: {vote_list_str}\n Enter yes to see consensus results!"
        
        #This will count type ofvotes for us and decide which has highest amount
        vote_counts = Counter(self.voting_list)
        total_votes= sum(vote_counts.values())
        #Have to find a way to see how many votes have been cast
        print(total_votes)
        max_count = max(vote_counts.values())
        consensus_options = [option for option, count in vote_counts.items() if count == max_count]
        if total_votes <2:
            consensus_message = f"Not enough votes have been cast to reach a consensus. Enter yes to retry or no to exit the program"
            print(f"Sending: {consensus_message}")
            self.client_socket.send(consensus_message.encode())
            sentence = self.client_socket.recv(1024).decode().strip()
            print(f"Received sentence: {sentence}")
            if sentence.lower() == 'yes':
                self.find_consensus()
            else: self.close_connection()

        # If there's a tie, you have to recast your vote
        if len(consensus_options) > 1:
            consensus_message = f"Consensus not reached.\n Press yes to recast votes!"
            print(f"Sending: {consensus_message}")
            self.client_socket.send(consensus_message.encode())
            sentence = self.client_socket.recv(1024).decode().strip()
            print(f"Received sentence: {sentence}")
            if sentence.lower() == 'yes':
                self.yes_message()
            else: self.no_message()
        
        else:
            #Consensus has been reached
            self.consensus = consensus_options[0]
            consensus_message = f"Consensus reached: {self.consensus}.\nEnter yes to start bidding or no to kill program!"
            print(f"Sending: {consensus_message}")
            self.client_socket.send(consensus_message.encode())
            sentence = self.client_socket.recv(1024).decode().strip()
            print(f"Received sentence: {sentence}")
            if sentence.lower() == 'yes':
                #self.information()
                self.handle_bids()
                self.client_socket.send("below auction".encode())

            else: 
                self.client_socket.send("skipped to else".encode())
                self.close_connection()

    #def auction(self):
        #initialises an auction for the information 
        # auction_message = f"starting auction! starting price 1$, what is your bid?"
        # self.client_socket.send(auction_message.encode())
        # sentence = self.client_socket.recv(1024).decode().strip()
        # print(f"Received sentence: {sentence}")

    def handle_bids(self):
        global global_base_price
        global_base_price = 1
        global global_current_bid
        global_current_bid = global_base_price
        global bids


        self.broadcast(f"what would you like to bid? Base price is {global_base_price}$\n")
        while True:
            bid = self.client_socket.recv(1024).decode().strip()

            try:
                int(bid)
                if int(bid) > global_current_bid:
                    global_current_bid = bid
                    self.broadcast(f"current bid is {global_current_bid}")
                    bids = True
                    self.auction()


                else:
                    self.client_socket.send("bid too low!".encode())

            except:
                self.client_socket.send("invalid input, bid again".encode())
            else:
                print("entered auction()")
                self.auction()


    def auction(self):
        if bids == True:
            self.timer()



    def timer(self):
        global bid_number
        global auction_state
        bid_number = 0
        if bid_number > 0:
            bid_number = 0
            time.sleep(5)
            if bid_number == 0:
                time.sleep(10)
                if bid_number == 0:
                    self.broadcast("Going once...")
                    time.sleep(3)
                    if bid_number == 0:
                        self.broadcast("Going twice...")
                        time.sleep(3)
                        if bid_number == 0:
                            self.broadcast("Going three times...")
                            self.broadcast(f"Auction for information concluded. Final Price: {global_current_bid}€.")
                            print(f"Auction for information concluded. Final Price: {global_current_bid}€")
                            auction_state = False
                            self.information()





    # def auction_logic(self):
    #     global auction
    #     if auction.auction_in_progress:
    #         self.client_socket.send(f"Current highest bid: ${auction.current_highest_bid} by {auction.highest_bidder if auction.highest_bidder else 'None'}".encode())
    #         while True:
    #             bid = self.client_socket.recv(1024).decode().strip()
    #             if bid.isdigit() and auction.bid(int(bid), self.client_socket):
    #                 self.broadcast(f"New highest bid: ${bid} by this client")
    #             else:
    #                 self.client_socket.send("Invalid bid or lower than current highest bid.".encode())
    #             if auction.check_auction_end():
    #                 if auction.highest_bidder == self.client_socket:
    #                     self.client_socket.send("You won the auction!".encode())
    #                     # Here you would add the logic to send the data of other clients
    #                 self.broadcast("Auction ended.")
    #                 auction.auction_in_progress = False
    #                 break
    #             time.sleep(1)  # to avoid busy waiting
            
    def information(self): 
        #This sends the list of clients that the server is connected tp
        info_message = f"Ok. Sending information now!\n Active connections:{self.active_connections}\nThank you for partaking! Enter any input to close connection!"
        print(f"Sending: {info_message}")
        self.client_socket.send(info_message.encode())
        sentence = self.client_socket.recv(1024).decode().strip()
        print(f"Received sentence: {sentence}")
        self.close_connection()

    def close_connection(self):
        #Closes the connections, all paths lead here 
        close_message = "Connection closed. Enter any letter to kill the program! Goodbye!"
        print(f"Sending: {close_message}")
        self.client_socket.send(close_message.encode())
        with global_lock:
            self.active_connections.remove(self.address)
        self.client_socket.close()
        
    def incorrect_answer(self):
        #This handles the wrong answers for the riddles, max 3 tries
        while self.max_attempts > 1:
            self.max_attempts -= 1
            wrong_message = f"Wrong answer. You have {self.max_attempts} more tries. Try again!"
            print(f"Sending: {wrong_message}")
            self.client_socket.send(wrong_message.encode())
            
            #If the answer is entered corectly on the 2nd/3rd try
            request = self.client_socket.recv(1024).decode().strip()
            print(f"Received sentence: {request}")
            if request.lower() == "david":
                self.correct_answer()
                return  # Exit the method if the answer is correct
                
        wrong_message = "Exceeded maximum attempts. Closing connection for security reasons. Enter any letter to close the program!"
        print(f"Sending: {wrong_message}")
        self.client_socket.send(wrong_message.encode())
        self.client_socket.close()

    def broadcast(self, message):
        # Convert the bid amount to a string and prepare the broadcast message
        for client_socket in global_client_socket:
            try:
                # Send the broadcast message to each connected client
                self.client_socket.send(message.encode())
            except Exception as e:
                # If there's an error sending the message, it could be due to a closed connection
                print(f"Error sending message to {client_socket}: {e}")
                # Here you should handle the cleanup of the closed connection
# def broadcast(message):
#     global global_lock, global_active_connections
#     with global_lock:  # Ensure that we have exclusive access to the active connections
#         for client_socket, addr in global_active_connections:
#             try:
#                 client_socket.send(message)  # Send the message to each connected client
#             except Exception as e:
#                 # If sending the message failed, remove the client from the active connections list
#                 print(f"Broadcast failed to {addr}: {e}")
#                 global_active_connections.remove((client_socket, addr))
#                 client_socket.close()

def main():
    #Threading locking
    global global_lock
    global_lock = threading.Lock()
    global global_active_connections
    global_active_connections = []
    global global_client_socket
    global_client_socket = []
    global global_voting
    global_voting_list= []
    
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <host> <port>")
        sys.exit(1)
    # Permanet socket that the server uses to listen on
    host, port = sys.argv[1], int(sys.argv[2])
    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    lsock.bind((host, port))
    lsock.listen()
    
    print("Server listening on IP address: " + host + " and port number: " + str(port))
    try:
        while True:
            # New individual client socket that can be used for threading
            client_socket, addr = lsock.accept()
            print("Accepted connection from:", addr)
            with global_lock:
                global_active_connections.append(addr)
                global_client_socket.append(client_socket)
            
            #Call the client handler class that will perform all the riddle logic
            client_handler = ClientHandler(client_socket, addr, global_active_connections, global_voting_list)
            client_handler.start()
    except KeyboardInterrupt:
        print("Caught keyboard interrupt, exiting")
        sys.exit()

            
        
if __name__ == "__main__":
        main()
